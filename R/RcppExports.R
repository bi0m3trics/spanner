# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

C_eigen_in_sphere <- function(las, radius, ncpu) {
    .Call(`_spanner_C_eigen_in_sphere`, las, radius, ncpu)
}

C_count_in_disc <- function(X, Y, x, y, radius, ncpu) {
    .Call(`_spanner_C_count_in_disc`, X, Y, x, y, radius, ncpu)
}

C_count_in_sphere <- function(las, radius, ncpu) {
    .Call(`_spanner_C_count_in_sphere`, las, radius, ncpu)
}

thinCloud <- function(las, voxel = 0.025) {
    .Call(`_spanner_thinCloud`, las, voxel)
}

RCropCloud <- function(las, xCenter, yCenter, len, circle, negative) {
    .Call(`_spanner_RCropCloud`, las, xCenter, yCenter, len, circle, negative)
}

getHoughCircle <- function(las, pixel = 0.05, rad_max = 0.25, min_den = 0.1, min_votes = 3L) {
    .Call(`_spanner_getHoughCircle`, las, pixel, rad_max, min_den, min_votes)
}

singleStack <- function(las, pixel = 0.05, rad_max = 0.25, min_den = 0.1, min_votes = 3L) {
    .Call(`_spanner_singleStack`, las, pixel, rad_max, min_den, min_votes)
}

stackMap <- function(las, hmin = 1, hmax = 3, hstep = 0.5, pixel = 0.025, rad_max = 0.25, min_den = 0.1, min_votes = 3L) {
    .Call(`_spanner_stackMap`, las, hmin, hmax, hstep, pixel, rad_max, min_den, min_votes)
}

houghStemPoints <- function(las, h1 = 1, h2 = 3, hstep = 0.5, radius = 0.25, pixel = 0.025, density = 0.1, votes = 3L) {
    .Call(`_spanner_houghStemPoints`, las, h1, h2, hstep, radius, pixel, density, votes)
}

houghStemPlot <- function(las, ptIds, h1 = 1, h2 = 3, hstep = 0.5, radius = 0.25, pixel = 0.025, density = 0.1, votes = 3L) {
    .Call(`_spanner_houghStemPlot`, las, ptIds, h1, h2, hstep, radius, pixel, density, votes)
}

getCircleRansac <- function(las, nSamples = 5L, pConfidence = 0.99, pInliers = 0.8) {
    .Call(`_spanner_getCircleRansac`, las, nSamples, pConfidence, pInliers)
}

ransacStemCircle <- function(las, segs, rads, nSamples = 5L, pConfidence = 0.99, pInliers = 0.8, tolerance = 0.05) {
    .Call(`_spanner_ransacStemCircle`, las, segs, rads, nSamples, pConfidence, pInliers, tolerance)
}

irlsStemCylinder <- function(las, segs, rads, nPoints = 500L, tolerance = 0.05) {
    .Call(`_spanner_irlsStemCylinder`, las, segs, rads, nPoints, tolerance)
}

irlsStemCircle <- function(las, segs, rads, nSamples = 500L, tolerance = 0.05) {
    .Call(`_spanner_irlsStemCircle`, las, segs, rads, nSamples, tolerance)
}

ransacStemCylinder <- function(las, segs, rads, nSamples = 10L, pConfidence = 0.95, pInliers = 0.8, tolerance = 0.05) {
    .Call(`_spanner_ransacStemCylinder`, las, segs, rads, nSamples, pConfidence, pInliers, tolerance)
}

ransacPlotCircles <- function(las, tId, segs, rads, nSamples = 5L, pConfidence = 0.99, pInliers = 0.8, tolerance = 0.05) {
    .Call(`_spanner_ransacPlotCircles`, las, tId, segs, rads, nSamples, pConfidence, pInliers, tolerance)
}

ransacPlotCylinders <- function(las, tId, segs, rads, nSamples, pConfidence, pInliers, tolerance) {
    .Call(`_spanner_ransacPlotCylinders`, las, tId, segs, rads, nSamples, pConfidence, pInliers, tolerance)
}

irlsPlotCylinders <- function(las, tId, segs, rads, nPoints, tolerance) {
    .Call(`_spanner_irlsPlotCylinders`, las, tId, segs, rads, nPoints, tolerance)
}

irlsPlotCircles <- function(las, tId, segs, rads, nPoints, tolerance) {
    .Call(`_spanner_irlsPlotCircles`, las, tId, segs, rads, nPoints, tolerance)
}

pointMetricsCpp <- function(las, kIds, whichMetrics) {
    .Call(`_spanner_pointMetricsCpp`, las, kIds, whichMetrics)
}

voxelIndex <- function(las, d) {
    .Call(`_spanner_voxelIndex`, las, d)
}

voxelMetrics <- function(las, voxelIds, whichMetrics) {
    .Call(`_spanner_voxelMetrics`, las, voxelIds, whichMetrics)
}

treeEigenHough <- function(las, ids, split_by, voxel = 0.05, rad = 0.25, is2d = FALSE, getSpace = FALSE) {
    .Call(`_spanner_treeEigenHough`, las, ids, split_by, voxel, rad, is2d, getSpace)
}

plotEigenHough <- function(las, ids, split_by, resplit_by, voxel = 0.05, rad = 0.25, is2d = FALSE, getSpace = FALSE) {
    .Call(`_spanner_plotEigenHough`, las, ids, split_by, resplit_by, voxel, rad, is2d, getSpace)
}

cppFastApply <- function(matrix, funcList) {
    .Call(`_spanner_cppFastApply`, matrix, funcList)
}

cppCircleFit <- function(las, method = "qr", n = 5L, p = 0.99, inliers = 0.8, nbest = 0L) {
    .Call(`_spanner_cppCircleFit`, las, method, n, p, inliers, nbest)
}

cppCylinderFit <- function(las, method = "nm", n = 10L, p = 0.95, inliers = 0.9, max_angle = 30, n_best = 20L) {
    .Call(`_spanner_cppCylinderFit`, las, method, n, p, inliers, max_angle, n_best)
}

treeIdsFromMap <- function(las, xycenters, uniqueIds, length, circle) {
    .Call(`_spanner_treeIdsFromMap`, las, xycenters, uniqueIds, length, circle)
}

bruteForceRansacCylinder <- function(las, nSamples, pConfidence, pInliers, nBest, maxAngle) {
    .Call(`_spanner_bruteForceRansacCylinder`, las, nSamples, pConfidence, pInliers, nBest, maxAngle)
}

bfStemCylinder <- function(las, segs, rads, nSamples = 10L, pConfidence = 0.95, pInliers = 0.8, max_angle = 30, tolerance = 0.05) {
    .Call(`_spanner_bfStemCylinder`, las, segs, rads, nSamples, pConfidence, pInliers, max_angle, tolerance)
}

bfPlotCylinders <- function(las, tId, segs, rads, nSamples = 10L, pConfidence = 0.95, pInliers = 0.8, max_angle = 30, tolerance = 0.05) {
    .Call(`_spanner_bfPlotCylinders`, las, tId, segs, rads, nSamples, pConfidence, pInliers, max_angle, tolerance)
}

